Services top-level entitlements

A service is an abstract definition of a computing resource within an application which can be scaled or replaced
indipendently from other components.
services are backed by a set of containers, run by the platform according to replication requirements and placement constraints.
they are defined by a Docker image and set of runtime arguments. all containers within a service are identically created with these arguments.

a Compose file must declare a services top-level element as a map whose keys are string representations of service names, and whose values are service definitions.
a service definition contains the configuration that is applied to each service container.

Each service may also include a build section, which defines how to create the Docker image for the service. if not used, the build section is ignored and the Compose file
is still considered valid.

Each service defines a runtime constraints and requirements to run its containers.
the deploy section groups these constraints and lets the platform adjust the deployment strategy to best match containers needs with available resources.
if not implemented the deploy section is ignored and the Compose file is still considered valid.

Attributes of service:

- annotations:
	defines annotations for the container. can use either an array or a map
	'annotations:
		com.example.foo: bar'
	or
	'annotations:
		- com.example.foo=bar'

- attach (requires Docker Compose 2.20.0 and later):
	when defined and set to "false" Compose does not collect service logs, until you explicitly request it to.
	default configuration is 'attach: true'

- build:
	specifies the build configuration for creating a container image form source (see "BuildSpecification.txt" file).

- blkio_config:
	defines a set of configuration options to set block I/O limits for a service.
	-- device_read_bps, device_write_bps: set a limit in bytes per second for read/write operations on a given device.
	   must have two keys:
	   - path: defines the symbolic path to the affected device
	   - rate: either an integer representing the number of bytes or as a string expressing a byte value
	-- device_read_iops, device_write_iops: set a limits in operations per second for read/write operations on a given device.
	   must have two keys:
	   - path: defines the symbolic path to the affected device
	   - rate: as an integer value representing the permitted number of operations pre second
	-- weight: modify the proportion of a bandwidth allocated to a service relative to other services.
			   take an integer value between 10 and 1000, with 500 as default
	-- weight_device: fine-tune bandwidth allocation by device.
	   must have two keys:
	   - path: defines the symbolic path to the affected device
	   - weight: an integer value between 10 and 1000

- cpu_count:
	defines the number of usable CPUs for service container

- cpu_percent:
	defines the usable percentage of the available CPUs

- cpu_shares:
	defines, as integer value, a service container-s relative CPU weight versus other container

- cpu_quota:
	configures CPU CFS(completely fair scheduler) quota when a platform is based on Linux kernel

- cpu_rt_runtime:
	configures CPU allocation parameters for platform with support for real-time scheduler.
	it can be either a integer value using microseconds as unit or a duration
	'cpu_rt_runtime: '400ms''
	'cpu_rt_runtime: '95000''

- cpu_rt_period:
	configures CPU allocation parameters for platform with support for a real-time scheduler.
	it can be either a integer value using microseconds as unit or a duration
	'cpu_rt_period: '1400ms''
	'cpu_rt_period: '11000''

- cpus:
	define the number of (potentially virtual) CPUs to allocate to service containers. this is a fractional number. '0.000' means no limit.

- cpuset:
	defines the explicit CPUs in which to perimt execution. can be a range or a list
	'cpuset: 0-3'
	'cpuset: 0,1'

- cap_add:
	specifies addictional container capabilities as string
	'cap_add:
		- ALL'

- cap_drop:
	specifies container capabilities to drop as string
	' cap_drop:
		- NET_ADMIN'

- cgroup (requires Docker Compose 2.15.0 and later):
	specifies the cgroup namespace to join. when unset, it is the container runtime's decision to select which cgroup namespace to use
	- host: runs the container in the Container runtime cgroup namespace
	-private: runs the container in its own private cgroup namespace

- cgroup_parent:
	specifies an optionaleparent cgroup for the container
	'cgroup_parent: m-executor-abcd'

- command:
	overrides the default command delcared by the container image, for example by Dockerfile "CMD".
	unlike the CMD instruction in Dockerfile, the command field doesn't automatically run within the context of the SHELL instruction defined in the image.
	in your command relies on shell-specific features you need to expicitly run it within a shell

- configs:
	let services adapt their behaviour without the need to rebuild a Docker image.
	Compose reports an error if config doesn't exist on the platform or isn't defined in the configs top-level element int Compose file.

	there are two syntaxes defined for configs:
	- short syntax:
		only specifies the config name. this grants the container access to the config and mounts point within the container defaults to "/<config-name>" in linux container.
		'services:
			redis:
				image: redis:latest
				configs:
				- my_config
				- my_other_config
			configs:
			my_config:
				file: ./my_config.txt
			my_other_config:
				external: true'
	- long syntax:
		provides more granularity in how the config is created within the service's task containers.
		- source: name of the config as it exists in the platform
		- target: path and name of the file to be mounted in the service's task containers
		- uid, gid: numeric uid or gid that owns the mounted config file within the service's task containers
		- mode: perissions for the file that is mounted within the service's task containers, in octal notation
	
- container_name:
	string that specifies a custom container name, rather tha a name generated by default

- 